<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Photoshoot Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#1e3a8a',
              'brand-secondary': '#3b82f6',
              'brand-light': '#dbeafe',
              'brand-dark': '#1e293b',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
          },
        },
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
          "react/": "https://aistudiocdn.com/react@^19.1.1/",
          "react": "https://aistudiocdn.com/react@^19.1.1"
        }
      }
    </script>
  </head>
  <body class="bg-gray-100 font-sans">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      // WARNING: This key is exposed in client-side code.
      // This is acceptable for personal use within the secure "Build apps with Gemini" environment.
      // DO NOT deploy this code to a public website without securing the key on a server.
      const apiKey = "AIzaSyAXcfrn6otK6Im56dGv_etvJQUhEtK5AWc";

      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';

      // --- Services ---
      const fileToBase64 = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.onerror = (error) => reject(error);
        });
      };

      const fileToGenerativePart = async (file) => {
        const base64Data = await fileToBase64(file);
        return {
          inlineData: {
            mimeType: file.type,
            data: base64Data,
          },
        };
      };

      const buildPrompt = (pose, styleImage, additionalNotes, productDetails) => {
        let detailInstructions = productDetails
          .filter(d => d.image && d.description)
          .map((d, index) => `- DETAIL SOURCE ${index + 1} ('${d.description}') must be replicated with perfect accuracy for its corresponding clothing part.`)
          .join('\n');

        return `**ABSOLUTE DIRECTIVE: HIGH-FIDELITY DIGITAL REPLICATION, 4K QUALITY**
You are a digital replication expert AI. Your task is to **COPY**, not to create. Generate a hyper-realistic, 4K, high-detail photograph.

**OBJECT ANALYSIS PROTOCOL:**
1.  **MODEL SOURCE:** Analyze the 'Model Source' image. Memorize the facial structure.
2.  **PRODUCT SOURCE:** Analyze the 'Product Source' images. Memorize the overall shape, color, and texture.
3.  **DETAIL SOURCE:** Analyze each 'DETAIL SOURCE' image. These are your highest priority references.
${detailInstructions}

**REPLICATION PROTOCOL (MANDATORY):**
1.  **FACE REPLICATION:** Reconstruct the face to be an **IDENTICAL MATCH** to the 'MODEL SOURCE'. No alterations.
2.  **PRODUCT REPLICATION:**
    a. Reconstruct the overall shape from the 'PRODUCT SOURCE'.
    b. For any area with a corresponding 'DETAIL SOURCE' (e.g., 'sleeve cuff'), you MUST **DIRECTLY REPLACE** the texture, color, and stitching with the information from that detail image. This is a direct copy-paste command, not a suggestion.
3.  **SCENE REPLICATION:** ${styleImage ? "Replicate the lighting, background, and mood from the 'Style Source' image." : "Create a clean, minimalist studio background with soft, even lighting."}
4.  **POSE:** Position the model in the following pose: ${pose}.
5.  **NOTES:** Apply the following notes: ${additionalNotes || 'None.'}

**FINAL WARNING:** The system will perform an automated pixel-similarity check between the detail source images (e.g., sleeve cuff) and the final output. Any discrepancy will result in failure. Absolute accuracy is the only goal.`;
      };

      const generatePhotoshootImage = async (pose, modelImage, productFrontImage, productBackImage, styleImage, productDetails, additionalNotes) => {
          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
          
          const promptText = buildPrompt(pose, styleImage, additionalNotes, productDetails);
          
          const imageParts = [];
          imageParts.push(await fileToGenerativePart(modelImage));
          imageParts.push(await fileToGenerativePart(productFrontImage));
          if (productBackImage) imageParts.push(await fileToGenerativePart(productBackImage));
          if (styleImage) imageParts.push(await fileToGenerativePart(styleImage));

          for (const detail of productDetails) {
              if (detail.image) {
                  imageParts.push(await fileToGenerativePart(detail.image));
              }
          }
          
          const payload = {
              contents: [{ parts: [{ text: promptText }, ...imageParts] }],
          };

          const maxRetries = 5;
          let attempt = 0;

          while (attempt < maxRetries) {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (response.ok) {
                const result = await response.json();
                if (
                    result &&
                    result.candidates &&
                    result.candidates.length > 0 &&
                    result.candidates[0].content &&
                    result.candidates[0].content.parts
                ) {
                    const candidate = result.candidates[0];
                    for (const part of candidate.content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                        }
                    }
                }
                console.warn("No image data found in API response.", result);
                return null; // Success, but no image data
            }

            if (response.status === 429) {
                attempt++;
                const errorBody = await response.json();
                console.warn(`Rate limit exceeded. Attempt ${attempt}/${maxRetries}. Retrying...`, errorBody);

                const errorMessage = errorBody.error?.message || '';
                const retryMatch = errorMessage.match(/Please retry in ([\d.]+)s/);
                let waitTime = (2 ** attempt) * 1000 + Math.random() * 1000; // Exponential backoff fallback

                if (retryMatch && retryMatch[1]) {
                    waitTime = parseFloat(retryMatch[1]) * 1000 + 500; // Use API suggestion + buffer
                    console.log(`API suggested retry after ${waitTime / 1000}s.`);
                } else {
                    console.log(`Using exponential backoff. Waiting for ${waitTime / 1000}s.`);
                }
                
                if (attempt >= maxRetries) {
                    throw new Error(`API request failed after ${maxRetries} attempts due to rate limiting.`);
                }

                await new Promise(resolve => setTimeout(resolve, waitTime));

            } else {
                // For other non-429 errors, fail immediately
                const errorBody = await response.json();
                console.error("API Error:", errorBody);
                throw new Error(`API request failed with status ${response.status}: ${errorBody.error?.message || 'Unknown error'}`);
            }
          }
          
          throw new Error(`API request failed after ${maxRetries} attempts.`);
      };

      // --- Components ---
      const Icon = ({ name, className = 'w-6 h-6' }) => {
        const icons = {
          upload: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" /></svg>,
          trash: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.067-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>,
          add: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></svg>,
          close: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>,
          download: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>,
          view: <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" /></svg>
        };
        return icons[name] || null;
      };

      const Spinner = ({ className = 'w-8 h-8' }) => {
          return <svg className={`${className} animate-spin text-brand-secondary`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>;
      };

      const ImageUpload = ({ id, title, onFileChange, isOptional = false, clearTrigger }) => {
        const [preview, setPreview] = useState(null);
        const fileInputRef = useRef(null);

        const handleFileChange = (event) => {
          const file = event.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onloadend = () => setPreview(reader.result);
            reader.readAsDataURL(file);
            onFileChange(file);
          }
        };

        const clearFile = useCallback(() => {
          setPreview(null);
          onFileChange(null);
          if (fileInputRef.current) {
            fileInputRef.current.value = '';
          }
        }, [onFileChange]);

        useEffect(() => {
          if (clearTrigger !== undefined && clearTrigger > 0) {
            clearFile();
          }
        }, [clearTrigger, clearFile]);

        return (
          <div className="w-full">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              {title} {!isOptional && <span className="text-red-500">*</span>}
            </label>
            <div className="mt-1 flex justify-center items-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md h-48 bg-white relative group">
              {preview ? (
                <>
                  <img src={preview} alt="Preview" className="max-h-full max-w-full object-contain" />
                  <button onClick={clearFile} className="absolute top-2 right-2 p-1.5 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity duration-200 hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" aria-label="Remove image">
                    <Icon name="trash" className="w-4 h-4" />
                  </button>
                </>
              ) : (
                <div className="space-y-1 text-center">
                  <Icon name="upload" className="mx-auto h-12 w-12 text-gray-400" />
                  <div className="flex text-sm text-gray-600">
                    <label htmlFor={id} className="relative cursor-pointer bg-white rounded-md font-medium text-brand-secondary hover:text-brand-primary focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
                      <span>Upload a file</span>
                      <input ref={fileInputRef} id={id} name={id} type="file" className="sr-only" onChange={handleFileChange} accept="image/*" />
                    </label>
                  </div>
                  <p className="text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
                </div>
              )}
            </div>
          </div>
        );
      };

      const Lightbox = ({ src, onClose }) => {
        useEffect(() => {
          const handleEsc = (event) => {
            if (event.key === 'Escape') onClose();
          };
          window.addEventListener('keydown', handleEsc);
          return () => window.removeEventListener('keydown', handleEsc);
        }, [onClose]);

        if (!src) return null;

        return (
          <div className="fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50 p-4" onClick={onClose}>
            <button className="absolute top-4 right-4 text-white p-2 rounded-full bg-black bg-opacity-50 hover:bg-opacity-75 transition-colors" onClick={onClose} aria-label="Close lightbox">
              <Icon name="close" className="w-8 h-8" />
            </button>
            <div className="relative max-w-full max-h-full" onClick={(e) => e.stopPropagation()}>
              <img src={src} alt="Generated photoshoot" className="max-w-full max-h-[90vh] object-contain rounded-lg shadow-2xl" />
            </div>
          </div>
        );
      };

      const GalleryItem = ({ src, onView, onDownload }) => {
        return (
          <div className="relative aspect-square group overflow-hidden rounded-lg shadow-md bg-gray-200">
            <img src={src} alt="Generated result" className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105" />
            <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-300 flex items-center justify-center gap-4">
              <button onClick={onView} className="p-3 bg-white/80 text-brand-dark rounded-full transform scale-0 group-hover:scale-100 transition-transform duration-200 delay-100 hover:bg-white" aria-label="View larger image">
                <Icon name="view" className="w-6 h-6" />
              </button>
              <button onClick={onDownload} className="p-3 bg-white/80 text-brand-dark rounded-full transform scale-0 group-hover:scale-100 transition-transform duration-200 delay-200 hover:bg-white" aria-label="Download image">
                <Icon name="download" className="w-6 h-6" />
              </button>
            </div>
          </div>
        );
      };

      // --- App Component ---
      const POSES = [
        "Full body, walking on a street, dynamic motion",
        "Medium shot, upper body, against a clean wall",
        "Sitting at an outdoor cafe, holding a coffee cup",
        "Leaning against a textured wall, looking away from camera",
        "Shot from behind, looking back over the shoulder",
        "Close-up portrait shot, focused on the product's texture near the neckline",
        "Action shot, model laughing or interacting with the environment",
        "Full body, standing, with hands in pockets",
        "Detailed shot focusing on the product's sleeves and cuffs",
        "Studio portrait on a neutral grey background"
      ];

      const LOADING_MESSAGES = [
        "Analyzing model's face...",
        "Stitching product textures...",
        "Setting up the virtual studio...",
        "Adjusting the lighting...",
        "Posing the model...",
        "Finalizing the 4K render..."
      ];

      function App() {
        const [modelImage, setModelImage] = useState(null);
        const [productFrontImage, setProductFrontImage] = useState(null);
        const [productBackImage, setProductBackImage] = useState(null);
        const [styleImage, setStyleImage] = useState(null);
        const [productDetails, setProductDetails] = useState([]);
        const [additionalNotes, setAdditionalNotes] = useState('');
        
        const [generatedImages, setGeneratedImages] = useState([]);
        const [isLoading, setIsLoading] = useState(false);
        const [loadingMessage, setLoadingMessage] = useState('');
        const [error, setError] = useState(null);
        
        const [lightboxImage, setLightboxImage] = useState(null);
        const [productInputClearTrigger, setProductInputClearTrigger] = useState(0);
        const [numImagesToGenerate, setNumImagesToGenerate] = useState(6);

        const isGenerateDisabled = !modelImage || !productFrontImage || isLoading;

        useEffect(() => {
          let interval;
          if (isLoading) {
            setLoadingMessage(LOADING_MESSAGES[0]);
            let i = 1;
            interval = window.setInterval(() => {
              setLoadingMessage(LOADING_MESSAGES[i % LOADING_MESSAGES.length]);
              i++;
            }, 3000);
          }
          return () => clearInterval(interval);
        }, [isLoading]);

        const addProductDetail = () => {
          setProductDetails([...productDetails, { id: crypto.randomUUID(), image: null, description: '' }]);
        };

        const updateProductDetail = (id, key, value) => {
          setProductDetails(productDetails.map(detail => detail.id === id ? { ...detail, [key]: value } : detail));
        };

        const removeProductDetail = (id) => {
          setProductDetails(productDetails.filter(detail => detail.id !== id));
        };

        const clearProductInputs = useCallback(() => {
          setProductFrontImage(null);
          setProductBackImage(null);
          setProductDetails([]);
          setProductInputClearTrigger(prev => prev + 1);
        }, []);

        const handleGenerate = async () => {
          if (isGenerateDisabled) return;
          
          setIsLoading(true);
          setError(null);
          setGeneratedImages([]);

          const posesToGenerate = POSES.slice(0, numImagesToGenerate);

          try {
            for (const pose of posesToGenerate) {
              if (!modelImage || !productFrontImage) break;
              
              const newImageSrc = await generatePhotoshootImage(
                pose, modelImage, productFrontImage, productBackImage,
                styleImage, productDetails, additionalNotes
              );

              if (newImageSrc) {
                  setGeneratedImages(prev => [...prev, { id: crypto.randomUUID(), src: newImageSrc }]);
              } else {
                  console.log(`Skipping pose: ${pose}`);
              }
              
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          } catch (err) {
              const errorMessage = err instanceof Error ? err.message : "An unknown error occurred.";
              console.error(err);
              setError(`Generation failed: ${errorMessage}`);
          } finally {
              setIsLoading(false);
              clearProductInputs();
          }
        };
        
        const handleDownload = (src) => {
          const link = document.createElement('a');
          link.href = src;
          link.download = `ai-photoshoot-${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        };

        return (
          <div className="min-h-screen bg-gray-50 text-brand-dark">
            <header className="bg-white shadow-sm sticky top-0 z-10">
              <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-4">
                  <h1 className="text-2xl sm:text-3xl font-bold text-brand-primary tracking-tight">AI Photoshoot Generator</h1>
                  <p className="text-gray-500 mt-1">Create professional fashion photoshoots in seconds.</p>
              </div>
            </header>

            <main className="container mx-auto p-4 sm:p-6 lg:p-8">
              <div className="flex flex-col lg:flex-row gap-8">
                
                <div className="w-full lg:w-1/3 flex flex-col gap-6">
                  <div className="p-6 bg-white rounded-lg shadow-md space-y-6">
                      <h2 className="text-xl font-semibold border-b pb-3">1. Core Assets</h2>
                      <ImageUpload id="model-image" title="Model's Face" onFileChange={setModelImage} />
                      <ImageUpload id="product-front" title="Product Image (Front)" onFileChange={setProductFrontImage} clearTrigger={productInputClearTrigger} />
                      <ImageUpload id="product-back" title="Product Image (Back)" onFileChange={setProductBackImage} isOptional clearTrigger={productInputClearTrigger}/>
                      <ImageUpload id="style-ref" title="Style Reference" onFileChange={setStyleImage} isOptional />
                  </div>

                  <div className="p-6 bg-white rounded-lg shadow-md space-y-4">
                      <h2 className="text-xl font-semibold border-b pb-3">2. Product Details (Optional)</h2>
                      {productDetails.map((detail, index) => (
                          <div key={detail.id} className="p-4 border rounded-md space-y-3 bg-gray-50">
                              <div className="flex justify-between items-center">
                                  <p className="font-medium text-sm text-gray-600">Detail #{index + 1}</p>
                                  <button onClick={() => removeProductDetail(detail.id)} className="text-red-500 hover:text-red-700 p-1">
                                      <Icon name="trash" className="w-5 h-5" />
                                  </button>
                              </div>
                              <ImageUpload id={`detail-image-${detail.id}`} title="Detail Image" onFileChange={(file) => updateProductDetail(detail.id, 'image', file)} isOptional clearTrigger={productInputClearTrigger} />
                              <input type="text" placeholder="e.g., sleeve cuff texture" value={detail.description} onChange={(e) => updateProductDetail(detail.id, 'description', e.target.value)} className="w-full border-gray-300 rounded-md shadow-sm focus:ring-brand-secondary focus:border-brand-secondary sm:text-sm" />
                          </div>
                      ))}
                      <button onClick={addProductDetail} className="w-full flex items-center justify-center gap-2 py-2 px-4 border border-dashed border-gray-400 text-sm font-medium rounded-md text-gray-600 hover:bg-gray-100 transition-colors">
                          <Icon name="add" className="w-5 h-5" />
                          Add Detail
                      </button>
                  </div>
                  
                  <div className="p-6 bg-white rounded-lg shadow-md space-y-4">
                      <h2 className="text-xl font-semibold border-b pb-3">3. Additional Notes (Optional)</h2>
                      <textarea value={additionalNotes} onChange={(e) => setAdditionalNotes(e.target.value)} rows={4} placeholder="e.g., model is holding a small handbag" className="w-full border-gray-300 rounded-md shadow-sm focus:ring-brand-secondary focus:border-brand-secondary sm:text-sm" />
                  </div>
                </div>

                <div className="w-full lg:w-2/3 lg:sticky top-24 self-start">
                  <div className="p-6 bg-white rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold border-b pb-3 mb-6">4. Generation</h2>
                    
                    <div className="mb-4">
                      <label htmlFor="num-images" className="block text-sm font-medium text-gray-700 mb-1">Number of Images</label>
                      <select id="num-images" name="num-images" value={numImagesToGenerate} onChange={(e) => setNumImagesToGenerate(Number(e.target.value))} className="w-full border-gray-300 rounded-md shadow-sm focus:ring-brand-secondary focus:border-brand-secondary sm:text-sm" disabled={isLoading}>
                          {Array.from({ length: 10 }, (_, i) => i + 1).map(num => <option key={num} value={num}>{num}</option>)}
                      </select>
                    </div>

                    <button onClick={handleGenerate} disabled={isGenerateDisabled} className="w-full py-3 px-4 text-lg font-semibold rounded-md text-white transition-all duration-300 ease-in-out bg-brand-primary hover:bg-blue-800 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:scale-100 flex items-center justify-center gap-3 transform hover:scale-105 active:scale-100">
                      {isLoading ? <Spinner className="w-6 h-6" /> : 'Generate Photoshoot'}
                    </button>
                    
                    <div className="mt-6 min-h-[4rem] flex flex-col items-center justify-center text-center">
                        {isLoading && (
                          <div className="text-gray-600">
                              <p className="font-semibold text-lg">{loadingMessage}</p>
                              <p className="text-sm">Please wait, this can take a few minutes...</p>
                          </div>
                        )}
                        {error && <p className="text-red-600 bg-red-100 p-3 rounded-md">{error}</p>}
                        {!isLoading && !error && generatedImages.length === 0 && <p className="text-gray-500">Your generated photoshoot will appear here.</p>}
                    </div>

                    {generatedImages.length > 0 && (
                      <div className="mt-6">
                          <h3 className="text-lg font-semibold mb-4">Results</h3>
                          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                              {generatedImages.map((image) => (
                                  <GalleryItem key={image.id} src={image.src} onView={() => setLightboxImage(image.src)} onDownload={() => handleDownload(image.src)} />
                              ))}
                          </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </main>
            <Lightbox src={lightboxImage} onClose={() => setLightboxImage(null)} />
          </div>
        );
      }

      // --- Mount Application ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>